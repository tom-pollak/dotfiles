{"sys4/URL.md":{"basename":"URL","content":"> Uniform Resoruce Locator\n\n","path":"sys4/URL.md","mtime":1665661531064,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"sys4/DHCP.md":{"basename":"DHCP","content":"> Dynamic Host Configuration Protocol\n\nAllows client to get their IP from a network when connecting\n\n1. Broadcast IP address 255.255.255.255 port 68\n\t1. Sent to every machine on the network\n\t2. Hopefully DHCP machine on network will reach out\n2. Host uses \"unknown\" address 0.0.0.0 port 67\n\t1. Machine will be \"leased\" an IP address by DHCP server for a certain amount of time\n\t2. If DHCP fails client assigned an IP address 169.254.0.0/16\n\n![[dhcp.png|300]]\n\n## Phases\n\n![[dhcp-phases.png]]\n\n- Yiaddr: Offered IP address\n\n","path":"sys4/DHCP.md","mtime":1665663737041,"tags":[],"aliases":"","headings1":"","headings2":"Phases","headings3":""},"icry/UF-CMA.md":{"basename":"UF-CMA","content":"> Unforgeability under [[Crytography Security#Chosen-Plaintext Ciphertext Attack]]\n\n- CMA: Adversary can make MAC queries\n- UF: Adversary wins by forging tag on a new message\n- UF-CMA: No feasible adversary has a non-negligible UF-CMA advantage\n\n\n![[uf-cma-game.png]]\n\n## Pseudocode\n\n![[uf-cma-pseudocode.png]]\n\n","path":"icry/UF-CMA.md","mtime":1665495210917,"tags":[],"aliases":"","headings1":"","headings2":"Pseudocode","headings3":""},"icry/Security Parameter.md":{"basename":"Security Parameter","content":"> If a [[Symmetric Encryption]] scheme is designed well, the only way an adversary can break it is by guessing $n$-bit key\n\n- Breaking scheme requires $O(2{n})$ guesses\n- Measure of expected *security level* of the scheme\n- **Convention** bit-length of key is referred to as its security level\n\t- Allows for comparison between primitives","path":"icry/Security Parameter.md","mtime":1665488628818,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/One-Time Pad.md":{"basename":"One-Time Pad","content":" - Assume shared key of unbound length is available\n\t- Does not fit [[Symmetric Encryption]] $|K| = n$\n\n\n> To encrypt a bit $M_{i}$, an unused bit $K_{i}$ is chosen, $C_{i}$ is calculated by bit-wise XORing $M_{i}$ and $K_{i}$\n\n- So we need a completely random bit $K_{i}$ of each bit of $M_{i}$, if both sides have this key, and it is completely independent of everything else we have *perfect security*\n- This is not practical, but is the idea behind [[Stream Ciphers]]\n\n$$\n\\large C_{i} \\leftarrow K_{i} \\oplus M_{i} \n$$\nIf $K$ is random:\n$$\n\\large Prob[C_{i} = 1 | M_{i} = 1] = Prob[C_{i} = 1 | M_{i} = 0] = \\frac{1}{2}\n$$\n$C_{i}$ is *information-theoretically* independent of $M_{i}$\n- Requires an infinite key for continued use\n","path":"icry/One-Time Pad.md","mtime":1665486723005,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/Stream Ciphers.md":{"basename":"Stream Ciphers","content":"Practical implementation of [[One-Time Pad]]\n\n- Generate long random-looking sequence (key stream) based on given key\n\t- **Key stream** used to encrypt stream of plaintext bits like [[One-Time Pad]]\n\n- Modelled as Pseudo-random generator (PSG)\n\t- Without knowledge of key, adversary not able to distinguish the output sequence from a random sequence\n\nRequirements:\n- Key stream bits must not be reused\n- Stream cipher must be a good PSG","path":"icry/Stream Ciphers.md","mtime":1665486814052,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/IND-CCA Security.md":{"basename":"IND-CCA Security","content":"> Allows the adversary to make both encryption and ***decryption*** queries\n\n- [[IND-CCA Security]] includes [[IND-CPA Security]] capabilities\n- Additional win condition: $C$ may not be queried\n\t- Otherwise dumb adversary may just decrypt $C$ and win\n\n![[IND-CCA.png|550]]\n\n## Pseudocode\n\n![[IND-CCA-pseudocode.png|550]]\n","path":"icry/IND-CCA Security.md","mtime":1665062040847,"tags":[],"aliases":"","headings1":"","headings2":"Pseudocode","headings3":""},"icry/NM-CCA Security.md":{"basename":"NM-CCA Security","content":"","path":"icry/NM-CCA Security.md","mtime":1665492866207,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/Indistinguishability.md":{"basename":"Indistinguishability","content":"> (IND) Encryption of different messages look essentially the same\n\n## Modelling Leakage\n\n\nAssume it is claimed that an adversary can find some information about our plaintext given a ciphertext of our scheme.\n\nHow do we test this claim?\n\n\n![[modelling-leakage.png]]\n\nThe adversary gives us a choice of messages, and we [[Symmetric Encryption|encrypt]] one at random. If the claim is correct, the adversary should then be able to tell which one was encrypted\n\n- All messages should have the same length i.e. $|M_{0}| = |M_{1}|$\n\t- Encryption schemes are not designed to hide the length of a message, just the contents\n\t- If this wasn't a requirement, the adversary could give us a short message and a long message and be able to tell by the length of the ciphertext\n\n*This is the first part, read [[IND-CPA Security]]*","path":"icry/Indistinguishability.md","mtime":1665058901585,"tags":[],"aliases":"","headings1":"","headings2":"Modelling Leakage","headings3":""},"icry/IND-CPA Security.md":{"basename":"IND-CPA Security","content":"*This is the second part to [[Indistinguishability]]*\n\nThe indistinguishability game does not give all [[Crytography Security#Adversary possible capabilities|adversary possible capabilites]] required for IND-CPA\n- [[Crytography Security#Adversary possible capabilities#Known-Plaintext Attack |Known-Plaintext Attack]]\n- [[Crytography Security#Adversary possible capabilities#Chosen-Plaintext Ciphertext Attack|Chosen-Plaintext Attack]] \n---\nBefore and after the game, the adversary is able to ask us to encrypt any message of its choice, for as many times as it needs\n\n![[IND-CPA-security.png]]\n\n## Pseudocode Format\n\nGiven an adversary $A = (A_{1}, A_{2})$, the IND-CPA game is run, giving adversary access to the encryption *oracle* $\\mathcal{Enc}_{k}(\\cdot)$\n- $(A_{1}, A_{2})$ represent the two phases:\n\t1. Start up to adversary returning the messages $M_{1}, M_{2}$\n\t2. Receiving ciphertext $C$ to returning $b'$\n- $\\mathcal{Enc}_k$ is the black box encryption method\n- **Advantage** of an adversary $\\text{Adv}{IND-CPA}(A)$: Probability the game outputs true\n- Scheme is IND-CPA secure if no adversary $A$ with a non-negligible advantage\n\n![[Psudocode-IND-CPA.png]]\n\n##### BUG: $A_{2}{\\mathcal{Enc}_K(\\cdot)}(C)$ should be $A_{2}{\\mathcal{Enc}(\\cdot)}(C)$ like phase 1\nSee: [[IND-CCA Security#Pseudocode]]\n\n## Breaking Deterministic Encryption\n\n##### TODO: Week 2 Exercise\n\n## Proving Security by Reduction\n\nGiven an adversary that can win the game with a probability larger than $0.5$, we can prove that the adversary can solve a well-known hard mathematical problem\n\n## Computational security\n\n> Security of symmetric encryption schemes is considered against adversaries that run in feasible time\n\n- A sub-exponential time complexity\n- Scheme is said to be $< notion >$ secure if there is no feasible / PPT adversary $A$ with a non-negligible advantage $Adv{notion}(A)$\n\n##### TODO: What is $< notion >$?\n- The amount of computational power??\n\n### Adversary given corresponding $C$ and $M$\n- Adversary can brute force $K$\n- $Dec_{k}(C) = M$ for each key\n- $O(2{n})$ time complexity\n- **Probability success of 1!**, but is over exponential time\n\n---\nFurther security: [[IND-CCA Security]]\n","path":"icry/IND-CPA Security.md","mtime":1665495210878,"tags":[],"aliases":"","headings1":"","headings2":"Pseudocode Format Breaking Deterministic Encryption Proving Security by Reduction Computational security","headings3":"Adversary given corresponding $C$ and $M$"},"icry/Encryption methods.md":{"basename":"Encryption methods","content":"## Encryption methods\n\n- XOR???\n\t- Would allow to partially decrypt if you got part of the key right\n\n","path":"icry/Encryption methods.md","mtime":1664964326402,"tags":[],"aliases":"","headings1":"","headings2":"Encryption methods","headings3":""},"icry/Encryption Algorithm Formal Syntax.md":{"basename":"Encryption Algorithm Formal Syntax","content":"**Key generation** (randomized)\n- Input: [[Security Parameter]] $n$\n- Output: $n$-bit key $K$\n- $K \\leftarrow KeyGen(n)$\n\n**Encryption**\n- Input: key $K$, message/plaintext $M$\n- Output: ciphertext $C$\n- $C \\leftarrow Enc(K, M)$ or $Enc_k(M)$\n- Algorithm can either be deterministic or probabilistic\n\t- No deterministic encryption scheme [[IND-CPA Security#Breaking Deterministic Encryptioin|is not IND-CPA secure]].\n\t\n\n**Decryption** (deterministic)\n - Input: key $K$, ciphertext $C$\n - Output: plaintext $M$\n - $M \\leftarrow Dec(K, C)$ or $Dec_k(C)$","path":"icry/Encryption Algorithm Formal Syntax.md","mtime":1665488489542,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/Electronic Codebook.md":{"basename":"Electronic Codebook","content":"(ECB)\n\n- How to encrypt a piece of data larger than a \"block\" in a [[Block Ciphers]]\n\n\nBreak $M$ into blocks, encipher separately\n\n\n**Not IND-CPA secure** as it is deterministic\n\nGiven an encrypted image, we take two pixels, and we are able to determine if they came from the same color or not\n\n![[deterministic-ecb-attack.png]]","path":"icry/Electronic Codebook.md","mtime":1665487686388,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/Crytography Security.md":{"basename":"Crytography Security","content":"## Adversary possible capabilities\n### Known-Plaintext Attack\n(KPA)\n> An adversary eavesdrop ciphertexts, and later find out about their corresponding plaintexts\n\n### Chosen-Plaintext/Ciphertext Attack\n(CPA/CCA)\n> An adversary may trick Alice/Bob to encrypt/decrypt plaintexts/ciphertexts of its choice\n\n## Adversary possible goals\n- *Ultimate goal:* Recovering secret key\n- Recovering plaintext for an eavesdropped ciphertext\n- Finding any information about plaintext from a ciphertext\n\t- $C$ does not leak any information about $M$ -- two ciphertexts are [[Cryptography#Indistinguishability | indistinguishable]]\n\n## Security Schemes\n\n- [[IND-CPA Security]]: Adversary has access to encryption method\n\t- Indistinguishable Chosen Plaintext Attack\n- [[IND-CCA Security]]: Adversary has access to both encryption & decryption method","path":"icry/Crytography Security.md","mtime":1665136541376,"tags":[],"aliases":"","headings1":"","headings2":"Adversary possible capabilities Adversary possible goals Security Schemes","headings3":"Known-Plaintext Attack Chosen-Plaintext/Ciphertext Attack"},"icry/Authenticated Encryption.md":{"basename":"Authenticated Encryption","content":"## Non-Malleability\n\n**Malleability** Given $C$, can generate $C'$ for a related message without knowing the message\n- Given $C$ for $M$, generate $C'$ for $M+1$\n- [[IND-CCA Security]] $\\implies$ [[Authenticated Encryption#Non-Malleability]]\n- [[IND-CCA Security]] $\\equiv$ [[NM-CCA Security]]\n\n##### Q: Is [[Cipher Block Chaining#Output Feedback Mode]] [[IND-CCA Security]]?\n- Authenticated encryption week 3\n\nHow to achieve [[IND-CCA Security]]?\n\n- Avoid malleability make sure when any $C$ are changed, they become invalid\n\t- Prove integrity / authenticity -- [[Message Authentication Codes]]\n\t\n\n## Encrypt-and-MAC\n\n- Encrypt the message, [[Message Authentication Codes|MAC]] the message\n\t- Output: ciphertext $(C, T)$ where:\n\t\t- $C = Enc_{K_{1}}(M)$ and $T = MAC_{K_2}(M)$\n- **NOT SECURE**\n\n## MAC-then-Encrypt\n\n- **NOT SECURE**\n\n## Encrypt-then-MAC\n\n- **SECURE**\n- $C = Enc_{K_{1}}(M)$ and $T = MAC_{K_2}(C)$\n\n\n","path":"icry/Authenticated Encryption.md","mtime":1665495144198,"tags":[],"aliases":"","headings1":"","headings2":"Non-Malleability Encrypt-and-MAC MAC-then-Encrypt Encrypt-then-MAC","headings3":""},"icry/Block Ciphers.md":{"basename":"Block Ciphers","content":"> Encipher fixed-length plaintext \"blocks\" using key to ciphertext blocks of same size\n\n- Essentially keyed permutation boxes\n- Similar to [[Stream Ciphers]] but encrypts multiple bits at once?\n\n- Pseudo-random *Permutation* (PRP)\n\t- 1-1 version of Pseudo-random function (PRF)\n- **AES is a block cipher**\n\nHow to encrypt a piece of data larger than a \"block\": [[Electronic Codebook]]\n\n![[block-cipher.png|200]]","path":"icry/Block Ciphers.md","mtime":1665488843000,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"dissertation/Content Based Search Meeting Notes.md":{"basename":"Content Based Search Meeting Notes","content":"- Use second approach -- OpenAI Clip\n\n","path":"dissertation/Content Based Search Meeting Notes.md","mtime":1665496743478,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"dissertation/Dissertation.md":{"basename":"Dissertation","content":"## Project ranking\n1. Content-based image search from image databases\n2. SAP engine -- Monte Carlo simulation evolutionary algorithms, may be quite hard as it is similar to poker, lots of unknowns, or is it just to get the most objectively best team\n3. Match betting methods shit\n4. \n5.\n\n---\n# Content-based image search from image databases\n\nNew search tools are required for organizing databases of images and/or extracting images with desired properties whenever needed. Image retrieval aims to select images that display certain characteristics from a database.\n\nThere are mainly two approaches: top to down and bottom-up. In the first approach, the algorithm looks for general characteristics of a specific image, such as characteristics that are used by humans to identify images that they see.\n\n> This one -- Clip\n\nIn the second approach, the algorithm identifies images based on the presence of specific syntactical or statistical combinations of such features. Such features can be learned by a machine learning program, and similar images are afterwards retrieved from the database using a search and match procedure. A database of images will be required to be used in this project (there are several public image databases, for example CorelDraw has such a database available). One or more algorithms will be implemented and compared to each other. By using Convolutional Neural Networks, CNN artificial intelligence has lately achieved very good results for object and image retrieval. The techniques developed will be compared in terms of retrieval accuracy and with respect to their ability to find images that display the desired features.\n\nGoals:\n\nYou will be expected to do the following:\n-   Understand the research area of the project and its context.\n-   Devise a specific methodology for reaching the project's objectives.\n-   Implement the methodology using Matlab, C or Python.\n-   Apply the methodology according to your implementation on various data and on entire databases if these are available.\n-   Analyse the results and compare with other approaches or when varying specific parameters.\n\n---\n\n## Title\n\n-   Indexing a Gallery of images with NLP text-to-image model\n\nExtension:\n-   Using motion detector to construct a gallery of images from a video\n-   Use Spotify Annoy Library to index the images\n-   Start with just one image in index\n-   Get accuracy and threshold maxima\n-   Start increasing number of images and index\n-   Increase number of forests, & size\n-   Use little table to store indexes and the like\n\n## Ideas\n- Motion detection to get \"blobs\" for CLIP\n- Matching nearest neighbour images with other images to create a general purpose object identification in video\n\t- Extension: Combine with multiple cameras and triangulate *any* object in a 3D space\n\t- Type in a query to search for, it shows you some images, like which object are you searching for, then goes through all the cameras and finds everywhere it was found, then can find the movement path of the object in 3D space over time\n\t\t- **ALL ON CAMERA**\n\t\t- Pop-up images -- Is this the person you're looking for?\n- Searching through a gallery of images\n\t- Identifying people to search for\n\t- Identifying faces\n- In embedded devices\n\n\n## Tasks\n\n1. Find a decent, lightweight, motion detector that can be altered on sensitivity\n2. Hook up a spooky like system with SLIP\n\t1. Get good hyperparameters: threshold, motion detector\n3. Image to Image -- compare blobs that come up in a search to link them together by threshold\n\t1. Some tinder style user interaction here -- is this the same person\n4. Link up a camera-server architecture to query multiple cameras and evaluate in central place\n\t1. Write some camera firmware -- Rust????????????\n\t2. Now we have output from multiple cameras to compare against\n5. Order detections in time order\n\t1. Same blob detected at the same time is the same object -- some triangulation???\n\t\t1. Not sure if this is necessary\n6. Provide a GUI interface \n7. Heatmap of where the object has been over time\n8. Able to save a search capture of all the relevant data of a person in a convenient encoding\n\n# References\n\n- OpenAI Clip Paper: [Learning Transferable Visual models From Natural Language Supervision](https://arxiv.org/abs/2103.00020)\n- MoTis-CLIP Paper: [Leaner and Faster: Two-Stage Model Compression for Lightweight Text-Image Retrieval](https://arxiv.org/abs/2204.13913)\n- [Spotify Annoy](https://github.com/spotify/annoy)","path":"dissertation/Dissertation.md","mtime":1665496645611,"tags":[],"aliases":"","headings1":"Content-based image search from image databases References","headings2":"Project ranking Title Ideas Tasks","headings3":""},"README.md":{"basename":"README","content":"# Year 3\n\n- ICRY: [[Cryptography]]\n- SYS4: [[Networking]]","path":"README.md","mtime":1665062231318,"tags":[],"aliases":"","headings1":"Year 3","headings2":"","headings3":""},"sys4/NTP.md":{"basename":"NTP","content":"> Network Time Protocol\n\n- Client-server, port 123\n- UDP\n- Hierarchy of refernce clocks and servers","path":"sys4/NTP.md","mtime":1665663885488,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"nets/Cracking Passwords.md":{"basename":"Cracking Passwords","content":"Brute Force\nDictionary: memorable words\nRainbow tables: pre-computed hashes\n\n## Password complexity\n\n$$\\LARGE \\text{alphabet}{length}$$\n\n","path":"nets/Cracking Passwords.md","mtime":1665747416207,"tags":[],"aliases":"","headings1":"","headings2":"Password complexity","headings3":""},"sys4/Address Resolution Protocol.md":{"basename":"Address Resolution Protocol","content":"(ARP)","path":"sys4/Address Resolution Protocol.md","mtime":1665748921408,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"sys4/The Internet.md":{"basename":"The Internet","content":"![[internet-heirarchy.png]]\n\n- Tier 1: Backbone\n- Tier 2: Regional ISP\n- Tier 3: access ISP\n\n---\n[[Internet Protocol Stack]]","path":"sys4/The Internet.md","mtime":1665749584172,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"sys4/HTTP.md":{"basename":"HTTP","content":"> HyperText Transfer Protocol\n\n- Stateless: no information recorded\n- Cookies used to maintain session information\n- CR LF (Carriage return, Line feed)\n- Phrase\n\n## Request\n\n![[http-request-packet.png]]\n\n### GET\n\n### POST\n\n### HEAD\n\n- GET request without body, just headers\n\n### OPTIONS\n\n- Options available to client, at least GET, HEAD must be implemented\n\n### PUT\n\n### DELETE\n\n### TRACE\n\n### CONNECT\n\n## Response\n\n![[http-response-packet.png]]\n\n- Phrase: OK, Bad request, Not found, Move permanently\n\n![[http-response-codes.png]]\n\n","path":"sys4/HTTP.md","mtime":1665751193157,"tags":[],"aliases":"","headings1":"","headings2":"Request Response","headings3":"GET POST HEAD OPTIONS PUT DELETE TRACE CONNECT"},"icry/excercises/ICRY Week 2 Excersises.md":{"basename":"ICRY Week 2 Excersises","content":"## Q1\n\n\nProve that any deterministic symmetric encryption scheme cannot be IND-CPA secure\n\n\nIn the IND-CPA game, the adversary has access to the encryption oracle, so can get the ciphertexts for $M_{1}$ and $M_{2}$, then compare which one is equal to the given ciphertext.\n\n## Q2\n\n\nIn order to check the integrity of encrypted messages, a hash of the message, i.e., H(M) for a publicly known function H, is appended to ciphertexts. That is, the encryption of message M under key K is computed as\n\n$$\nEnc(K, M) || H(M)\n$$\n\n##### ANSWER\nFor this scheme to be considered “good” it must satisfy at least the IND-CPA notion of security. However, there is a simple chosen-plaintext attack on this scheme. An adversary picks two n-bit messages M0 and M1, and obtains a ciphertext, which contains the hash $H(M_b)$ where $b \\leftarrow \\$ {0, 1}$ is the challenge bit that the adversary aims to guess. Now the adversary hashes both M0 and M1 using H (which is publicly known and does not use any secret keys), and checks which which one matches the hash in the ciphertext.\n\n### Symmetric Encryption\n\nAssuming the hash function is irreversible by the attacker, the encryption scheme is cryptographically secure.\n\nConfidentiality: \n- Neither the encryption function nor the hash function will give any information on the key or message itself\n\nIntegrity:\n- Modifying the encrypted data will give a different message on decryption, but as the attacker does not know the key $K$, they cannot decipher what the new message will be. Therefore, they will not be able to change the hash function to match\n\nAuthenticity:\n- While this is similar to integrity, an attacker would not be able to impersonate a client, as they do not know the key $K$ to encrypt their message with\n\n### Public Key\n\nThis would not be cryptographically secure, as the public key is known to the attacker, so the integrity of the encryption scheme would be damaged, for the reasons above.\n\n### Q3\n\nConsider an encryption scheme that compresses its input messages before encrypting them. Is this an IND-CPA secure encryption scheme? Discuss your answer.\n\n\nThis would give information leakage as the adversary can give two messages with different compression effectiveness.\n- E.g. $M_{1} = 0{n}, M_{2} = \\$\\{0, 1\\}{n}$\n- $M_{1}$ can be compressed effectively, while $M_2$ cannot\n\nAs encrypted message is proportional to message size the adversary can infer which message was encrypted by ciphertext length.\n\n\n~~Original answer: This is not a secure encryption scheme, as any messages which are the same up to cut off will cause collisions, causing possible authenticity errors. Instead of compressing the message, it would be better to send it in multiple chunks.~~\n\n### Q4\n\n\nFormulate, as a game between a challenger and an adversary, a notion of unrecoverability of messages under a chosen-plaintext attack.\n\n\n**Recoverability Game** Recover $M$ from $Enc(K, M) =: C$\n- Also known as OW-CPA (one-way)\n- Get message from ciphertext\n- Has IND-CPA powers\n\n\nK <- KeyGen()\nM <- $M # random choice in the universal space of M\nC <- Enc(K, M)\nSend adversary C\nReceive M'\nWin condition: M = M'\n\n\nIND-CPA secure $\\implies$ OW-CPA secure\n\n### Q5\n\n\nSuppose you are provided with two encryption schemes, one of which is IND-CPA secure, but you do not know for which one this is the case. Can you think of a way to build an encryption scheme that is IND-CPA secure using these two schemes?\n\n\nLet the two encryption schemes be $Enc_{1}, Enc_{2}$\nCreate a new scheme $Enc_{3}$, such that $Enc_{3}(K, M) = Enc_{1}(K, Enc_{2}(K, M))$\n\nThis is IND-CPA secure if at least $Enc_{1}$ or $Enc_{2}$ is IND-CPA secure\n\nCase 1: $Enc_{2}$ is not IND-CPA secure\n- As $Enc_{1}$ is IND-CPA secure, its message is never exposed to the adversary\n- This is the trivial case\n\nCase 2: $Enc_{1}$ is not IND-CPA secure\n- This would cause the leakage of the message $Enc_{2}(K, M)$\n- However as $Enc_{2}$ is IND-CPA secure, we learn no information about $M$\n\n- Time complexity: $2n$\n- Space complexity: $n$\n\n---\nSecond Method\nLet $\\Delta \\leftarrow \\$\\{0, 1\\}{n}$ -- this is random noise\n$M_{1} = M \\oplus \\Delta$\n$M_{2}= \\Delta$\n\n$Enc_{3}(K, M) = Enc_{1}(K, M_{1})||Enc_{2}(K,M_{2})$\n\n**One-time pad** $M \\oplus \\Delta$\n- This does *not* leak\n\n- Time complexity: $n$ (in paraell)\n- Space complexity: $2n$","path":"icry/excercises/ICRY Week 2 Excersises.md","mtime":1665751794153,"tags":[],"aliases":"","headings1":"","headings2":"Q1 Q2","headings3":"Symmetric Encryption Public Key Q3 Q4 Q5"},"sys4/Networking.md":{"basename":"Networking","content":"# Networking\n\n## Frequency & bit rate\n\n> Carrier frequency must be much higher than bit rate, so the receiver can identify the frequency. E.g. must have 10 cycles of the same frequency to convey frequency\n\n- Maximum frequency dictated by how quickly a channel can change\n- Data bandwidth refers to bit-per-second, not cycles-per-second. This could be a confusing term\n\t- Also refers to raw data bits, rather than bits of information received\n\t- i.e. data packets contain bits for error detection, packer routing etc. Only a fraction of the bits actually contain useful information\n\n![[packer-structure.png|400]]\n\n## Frequency division multiplexing\n\n> Signals transmitted at the same time over different parts of the frequency spectrum\n\n- E.g. Data is transferred over 2.4Ghz and 5Ghz Wi-Fi bands at the same time\n\n\n## Time division multiplexing\n\n> Signal uses full channel, but only for time slots\n\n- Synchronized switches, transmission time divided between users\n- **Frame** Allocated transmission time of a single slot\n- Can be synchronous - allocated even if data does not need to be transferred, async - reallocate unused slots\n\n## Packet Switching\n\n- No limit on number of users, more suited for bursty communication\n- Use protocol stack to transport packets \n\n\n## Latency\n\n- Latency is one-way delay\n\n$$\n\\text{Latency} = \\text{Propagation delay} + \\text{Transmission delay} + \\text{Queueing delay}\n$$\n$$\n\\text{Propagation (vacuum)} = Distance \\div \\text{Speed of light}\n$$\n$$Transmission = Size \\div Bandwidth$$\n\n## Time To Live\n\n> (TTL) \n\n- Ensures \"lost\"/ unrouted packets are removed from the network\n- Initially host sets this to the maximum number of *hops*\n\t- (255, 64, 128) -- depending on how quickly you want \"lost\" packets to be removed\n- Each time a packet passed through a router its value is decremented by 1\n- When value reaches 0 the routing device sends back \"Time exceeded\" error message to transmitting host\n\n- **Traceroute** Sends out a series of packets, incrementing TTL each time and records send back \"Time exceeded\" error message\n\t- However routers do not have to send back an error message, just like ping\n\n\n## IP Addresses\n\nTo identify the network address the Raspberry Pi is connected to (i.e. address of the network) we perform bitwise AND f the subnet mask and the IP address\n\n\nIP addr       192.168.100.254  11000000 10101000 01100100 11111110\nSubnet mask   255.255.0.0      11111111 11111111 00000000 00000000\n==================================================================\nNetwork       192.168.0.0      11000000 10101000 00000000 00000000\n\n\n### Private\n- 192.168.[Subnet ID].[Machine ID]\n\n## Network basics\n\n> Client server model\n\n- Messages sent on a socket, identified by port number\n- Client uses temporary port for the server to communicate back to the client\n\t- Uses random dynamic port (49152 - 65535)\n\n---\n\n[[Internet Protocol Stack]]","path":"sys4/Networking.md","mtime":1665751849322,"tags":[],"aliases":"","headings1":"Networking","headings2":"Frequency & bit rate Frequency division multiplexing Time division multiplexing Packet Switching Latency Time To Live IP Addresses Network basics","headings3":"Private"},"sys4/IP.md":{"basename":"IP","content":"","path":"sys4/IP.md","mtime":1665751890049,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"sys4/DNS.md":{"basename":"DNS","content":"> Domain Name System Protocol\n\n- Client-server: default port 53\n- Communicate across UDP\n- Used by [[URL]]\n- Fully qualified domain name: defines all levels from top to bottom csteach0.york.ac.uk. -- trailing dot is important\n- **CNAME**  alias for a domain name\n\t- Multiple domains share same [[IP]]\n- **A** IPv4\n- **AAAA** IPv6\n\n![[dns-heirarchy.png|500]]\n\n## DNS Query / Packet\n\n- Minimise overhead previous DNS lookups are cached\n\n\n![[dns-packet.png|700]]\n\n\n- Question: Name, Type, Class\n- Answer: Authority & Additions: Use RR format\n\n### Iterative Packet\n\n- Round robin DNS\n\t- Response contains a list of potiential servers that host identical services\n\n![[iterative-dns-request.png|300]]\n\n### Recursive Packet\n\n- Not used, as it causes more computation among multiple machines\n\n![[recursive-dns-request.png|300]]\n","path":"sys4/DNS.md","mtime":1665751886503,"tags":[],"aliases":"","headings1":"","headings2":"DNS Query / Packet","headings3":"Iterative Packet Recursive Packet"},"sys4/FTP.md":{"basename":"FTP","content":"- Client-server model\n- Stateful protocol\n- SFTP secure\n\nTwo channels:\n- Command / control channel: 21\n\t- Persistent: use QUIT to close\n- Data channel: 20\n\t- Not persistent: closed after receiving data\n\n\nOptions:\n- USER\n- PASS\n- PASV\n- CWD\n- LIST\n- SIZE\n- DELE\n- STOR\n- RETR\n- QUIT","path":"sys4/FTP.md","mtime":1665752225745,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/excercises/ICR Week 3 Excersises.md":{"basename":"ICR Week 3 Excersises","content":"## Q1\n\n### i\n\n\n\n### ii\n\n","path":"icry/excercises/ICR Week 3 Excersises.md","mtime":1665851225872,"tags":[],"aliases":"","headings1":"","headings2":"Q1","headings3":"i ii"},"nets/Zero Knowledge Proofs.md":{"basename":"Zero Knowledge Proofs","content":"","path":"nets/Zero Knowledge Proofs.md","mtime":1665866921390,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"nets/Security Concepts.md":{"basename":"Security Concepts","content":"## Authority\n\n> Doesn't care who is attempting to get into it, as long as they have the right key\n\n\n- Authority is linked to identity\n\n\nmermaid\nflowchart LR\n\na[identity] --> b{authentication}\nb -- yes --> d(Grant authority)\nb -- no --> c(Access denied)\n\n\n**Identity v Authority**  Asking to see ID for alchol, didn't need to know the identity of the customer, but need ed to know they were authorised to buy alcohol\n\n## Identity\n\n![[identity-venn.png|500]]\n\n- Driving a car: Key, Driving licence, insurance, ownership documents\n- Train: Train ticket\n- Campus: Student ID\n\n How can we establish identity to a level where we are willing to rely on them?\n\n## Authentication\n\n### Challenge-Response Model\n\n1. Present a token that makes a claim about our identity -- username.\n2. Challenge the claimant to provide a stronger proof -- password.\n\t- Password is a *shared secret*\nMust be a mechanism for generating a password, mapping to a username, and sharing a password and mapping with both parties\n- Problem: Ensure we share information with only correct parties\n- Need to establish *identity tokens*, so we know who we're communicating with\n\t- We lack [[Security Concepts#Trust]]\n\n### Passwords\n\n### User Management\n\n\n## Trust\n\n- **Chain of trust**\n- **Root authority**\n\n- System relies on an external root authority: passport link back to a central authority -- the government\n- If the root authority isn't external, we have to establish our own rules for evaluating trust\n\n### Enrolment\n\n> Process where a trusted subject introduces a new subject to the system, creates appropriate tokens, and declares authority for the new subject\n\n\n\n### Issuance\n\n\nSending passwords: Passwords must be hashed for security reasons in case the server is compromised\n\n[[Cracking Passwords]]\n\n## Authentication Credential Lifecycle\n\n![[authentication-credential-lifecycle.png|500]]\n\nSuspension:\n- Re-assignment: Generate new credential\n- Resynchronize: Remind user what password are\n- Re-activate: user prove who they are with alternative information\nTermination: When credentials no longer required, remove them\n\n\n## Alternative authentication\n\n### CAPTCHA\n\n> Completely Automated Public Turing test to tell Computers and Humans Apart\n\n### Graphical Passwords\n- Pattern\n\n### Biometrics\n\n- Universal\n- Unique\n- Persistent\n- Collectable\n\n---\n[[Zero Knowledge Proofs]]\n","path":"nets/Security Concepts.md","mtime":1665867113854,"tags":[],"aliases":"","headings1":"","headings2":"Authority Identity Authentication Trust Authentication Credential Lifecycle Alternative authentication","headings3":"Challenge-Response Model Passwords User Management Enrolment Issuance CAPTCHA Graphical Passwords Biometrics"},"nets/Trusted Computer Base.md":{"basename":"Trusted Computer Base","content":"(TCB)\n\nConsists of:\n\n**Reference Monitor** Enforces access control policies\n- Access routins for potientially dangerous operations\n\t- e.g. disk write, network access\n- Assumed to have no trojans in it itself\n\n**Access Enforcement Facility** (AEF) Checks with ADF to see if the process can use restricted operations\n- Bit like an API for the ADF?\n\n**Access Control Decision Facility** (ADF)\n\nHas to be checked twice:\n1. Check if process is allowed to perform restricted operation\n2. Check if process is allowed to perform restricted operation on that object (if 1. passes)\n\n![[trusted-computer-base.png]]\n\n","path":"nets/Trusted Computer Base.md","mtime":1665867734042,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"Trojan Horse.md":{"path":"Trojan Horse.md","basename":"Trojan Horse","mtime":0,"content":"","aliases":"","headings1":"","headings2":"","headings3":"","doesNotExist":true,"parent":"nets/Access Control.md"},"nets/Access Control.md":{"basename":"Access Control","content":"## Mandatory Access Control\n\n(MAC) -- not to be confused with message authentication codes\n\n> Decisions are made at a high-level, beyond the control on the owner of the object\n\n- Central authority\n\t- Determines what is accessible to whom\n- User cannot change access rights\n\nUses: Military / high-security environments\n\nGood defence against [[Trojan Horse]]\n- Higher degree of control over process actions\n- Does not allow a subject to change privileges itself, prevents rogue processes from altering permissions\n\n\n## Discretionary Access Control\n\n\n> Owner of object decides which subjects have access to the object, and what the rights should be \n\n(DAC)\n\nImplementations:\n- User accounts\n- Owner/Group/Other permissions\n- Access control lists\n- Capabilities (temporary grants of access using a secret)\n\nProblem: [[Trojan Horse]] runs with privileges of the process that contains it\n- DAC performs no check on the \"intent\" of a subject before granting access\n- Protection: Restricting untrusted software privileges -- [[Trusted Computer Base]]\n\n## Access Control List\n\n> A mapping of subjects and objects to actions\n\n$$(S, O, A)$$\n\nwhere $A$ is an access matrix such that $A[s, o] \\subseteq P, \\text{ where } S \\in S, o \\in O, P \\subseteq \\{r, w, x\\}$ ","path":"nets/Access Control.md","mtime":1665868151887,"tags":[],"aliases":"","headings1":"","headings2":"Mandatory Access Control Discretionary Access Control Access Control List","headings3":""},"nets/Security Models.md":{"basename":"Security Models","content":"## Bell-LaPadula\n\n> Formalization of military style policy\n\n**Secure Information Flows** Assign every subject $s$ and object $o$ to a security class $C$ which is the *clearance* $C_{s}$ or *sensitivity* $C_{o}$ of that entity\n\nE.g.\n1. Top Secret.\n2. Secret\n3. Classified\n4. Restricted\n5. Unclassified\n\nReading: **Simple Security Property** $C_{o} \\leq C_{s}$\n\nWriting: **\\*-Property** No subject may write to a lower level than the object is currently accessing\n- $C_{p} \\geq C_{o}$\n\nWe can produce a model of states within the systems as a whole from these two properties\n\n## Biba Integrity\n\n> Implementation of Commercial policy, where object integrity is paramount\n\n**Integrity Levels** Work the same way as clearance and sensitivity, with different effects\n\n**Simple Integrity Property** Subject may not read from an object of lower integrity because it may taint the subject\n- $I_{s} \\leq I_{o}$\n\n**\\*-Integrity Property** Information from a low integrity object must never be written to a higher level object\n- $s$ has accessed $o$ and wants to write to $p$\n- $I_{p} \\leq I_{o}$\n\n## Brewer Nash\n\n> Allows apparent security levels to \"float\" in order to remove artificial barriers\n\n**Conflict of Interest** (COI) Classes of which members are declared to conflict with each other\n- Subject may only access objects where COI classification of that object's parent dataset does not conflict with COI of any information subject already possesses\n\nad-note\nThis is kinda a superset of [[Security Models#Bell-LaPadula]]\n\n\n### Formal Syntax\n\nLet L be a set of security labels $(x, y)$, one such label associated with each object.\n\nFunctions $X(o)$ and $Y(o)$ determine the $x$ and $y$ components of this security label for a given object $o$\n\nEnforce property by definition: $y_{1} = y_{2} \\implies x_{1} = x_2$\n- Any two objects $o_{1}$ and $o_{2}$ belong to the same company dataset then they also belong to the same conflict of interest class\n- So by implication, if any two objects belong to different COI classes they must belong to different datasets","path":"nets/Security Models.md","mtime":1665869771918,"tags":[],"aliases":"","headings1":"","headings2":"Bell-LaPadula Biba Integrity Brewer Nash","headings3":"Formal Syntax"},"TCP.md":{"path":"TCP.md","basename":"TCP","mtime":0,"content":"","aliases":"","headings1":"","headings2":"","headings3":"","doesNotExist":true,"parent":"sys4/Internet Protocol Stack.md"},"sys4/Internet Protocol Stack.md":{"basename":"Internet Protocol Stack","content":"> An abstraction to manage the complexity of the process. The problems faced at the physical layer e.g. electrical interface are much different from problems faced on the application layer\n\n![[networking-protocol-stack.png|500]]\n\n![[internet-protocol-stack-packet.png]]\n\n- As data goes down the protocol stack additional headers are added to implement each protocol\n- As data goes up the protocol stack headers are removed as packets are received by hosts, routers, etc.\n- Nodes do not need to implement every layer in stack\n\t- E.g. Router may only implemnt Network, Link and Physical as it does not send its own packets\n\n## Application Layer\n\n> API to network, e.g. web browser\n\n- [[DNS]]\n- [[DHCP]]\n\n### Host & Domain Names\n\n> Internet phone box\n\nOld solution: maintain single centralized host table e.g. /etc/hosts mapping hostnames to IP addresses\n- Works, but unmanageable\n\n### Host and Domain Names\n\nRegional Internet Registries (RiR) given AS number and globally allocated IP by Internet Assigned Numbers Authority (IANA)\n\n## Transport\n\n> Breaks message into *segments* to be transferred\n\n- [[TCP]]\n- [[UDP]]\n\nError detection, congestion control, retransmission of lost packets\n\n$$D_{end-end} = N_{stages}(D_{proc} + D_{que} + D_{tran} + D_{prop})$$\n\n**Processing delay** Time takes to load message & encrypt\n**Queuing delay**\n**Transmission delay** Time taken to move packets onto the wire: $\\frac{bandwidth}{length\\ of\\ packet}$\n**Propagation delay** Time of Flight (ToF)\n\n![[transport-layer-multiplex.png]]\n\n","path":"sys4/Internet Protocol Stack.md","mtime":1666011808362,"tags":[],"aliases":"","headings1":"","headings2":"Application Layer Transport","headings3":"Host & Domain Names Host and Domain Names"},"nets/Reputation.md":{"basename":"Reputation","content":"## Contextual Reputation\n\nFactors:\n- Behaviours exhibited\n\t- e.g. website known to host malware\n- Proximity to neighbours (associated reputation)\n\t- IP address/domain name in a block with unreputable hosts\n- Acquired identity (inherited reputation)\n\t- IP address of previously bad host\n\n\n![[computer-based-reputation-system.png]]\n\n**Evaluators** Users, Registered users, or restricted users (confirmed purchase)\n\n**Input** Manual, Automated direct: Monitoring systems & crash reports, Automated indirect: gathered from other reputation systems\n\n**Processing** Reputation metric, deterministic or probabilistic, answer binary, continuous or discrete, temporal aspects: old input useful as new\n\n## Attack and Defences\n\n> Might seem useful to consider motivation for an attack, but in practice it can be more useful to consider the capabilities of an attacker.\n\nModel attacker based on factors:\n- Location -- Inside or outside system\n- Number -- working alone or part of a team\n- Interests -- selfish / rational or malicious / revenge\n- Active (modifying existing data, abusing system) or Passive\n\n### Self-promotion\n\nDisguise themselves as real evaluators and enter fake positive input, made worse with [Sybil attack](https://en.wikipedia.org/wiki/Sybil_attack)\n\nDefences\n- Proof of interaction / purchase\n- Attack-resistant metrics\n- time windows -- user can only provide a single input in a given week\n\nDefences can be reduced by *collusion* -- buyer and seler conspire together to fake transactions\n\n### Whitewashing\n\n> Resetting reputation\n\n- Leaving and rejoining under another identity\n- Self-promotion to mitigate negative reputation\n- Becoming a *mole* -- create an identity which leaves both positive and negative feedback, but can be used to affect rating of specific users\n\n\t### Slandering\n\n> Damage someone else's reputation\n\n\n## Metrics\n\nMedian, Mode, Mean\n\n**Trimmed mean** Remove outlier values (5%)\n\n**Winsor Mean** Replace outliers with values closer to the middle range\n\n## Trust-enhanced reputation\n\n[[Security Concepts#Trust]]\n\nWe can give each evaluator a corresponding trust level, for a binary trust (trusted, untrusted)\n$$\n\\forall e_{i}\\ \\exists\\ t_{i} \\in \\{0, 1\\}\n$$\n\n$$\n\\text{Weighted mean} = \\frac{\n\\sum\\limits_{i=1}{n}{t_{i}x_{i}}\n}{\\sum\\limits_{i=1}{n}t_i}\n$$\n\n- We now have a secondary problem, how do we determine trust of our evaluators?\n- And if we want to change trust level, how do we know if/when they provide an honest/ dishonest input?","path":"nets/Reputation.md","mtime":1666015626293,"tags":[],"aliases":"","headings1":"","headings2":"Contextual Reputation Attack and Defences Metrics Trust-enhanced reputation","headings3":"Self-promotion Whitewashing"},"icry/Message Authentication Codes.md":{"basename":"Message Authentication Codes","content":"![[message-authentication-codes.png|400]]\n\n\nGoals:\n- Authenticity / Integrity -- these are both the same in this context\n- See [[Cryptography#Definitions]]\n- **Game** [[UF-CMA]]\n- [[HMAC]]\n\n## Usage\n\n- **MACs do not need to be randomized**\n- MACs are *deterministic*\n\t- Every time we run it on the same message and same key it gives the same tag\n\n## Construction\n\n> MAC tags need to be unpredictable for adversary\n\n- Use pseudo-random functions (PRF)\n\t- $MAC(K, M) \\triangleq PRF(K, M)$\n- Can be shown that if PRF secure MAC is UF-CMA\n\n## Length extension attack\n\nNaive: [[Cipher Block Chaining]]-[[Message Authentication Codes]]\n![[naive-cbc-mac.png|250]]\n\n1. Query MAC for $M_{1}$ and get $T_{1}$\n2. Query MAC $M_{2} \\oplus T_{1}$ and get $T_{2}$\n3. Output $M' = M_{1} || M_{2}$ and $T' = T_{2}$\n\n## Replay attacks\n\nIf $(M, T)$ is eavesdropped and replayed back to Bob, it will verify again\n\n- So MAC do not protect against replay attacks\n- Practical solution: use counters or timestamps\n\n## Secure CBC-MAC\n\n![[secure-cbc-mac.png]]\n\n\n\n## Formal Syntax\n\n**Key generation** (random) $K \\leftarrow KeyGen(n)$\n**MAC** (generation) (deterministic) $T \\leftarrow MAC_{K}(M)$\n**Verification** (deterministic) $T = MAC_{K}(M)$\n- Verification is a trivial algorithm where we run the message with the key and check the tags are the same\n\n## Error detection codes\n\n**Authenticity without a key is impossible** The algorithm is public, so an adversary can change $M$ to $M'$, then generate a new tag $T'$ to replace $(M, T)$ with $(M', T')$\n\n- However, it is useful to provide an MD5 hash against *uncontrolled* communication or storage errors\n\n## Security\n\n### Adversary capabilities\n\n- **Passive** Eavesdrop $(M, T)$ pairs\n- **Active** [[Crytography Security#Chosen-Plaintext Ciphertext Attack |chosen message attack]]\n\n### Goals\n- Breaking integrity / authenticity -- **Forgery:** trick bob into accepting message not sent by Alice \n","path":"icry/Message Authentication Codes.md","mtime":1666021419856,"tags":[],"aliases":"","headings1":"","headings2":"Usage Construction Length extension attack Replay attacks Secure CBC-MAC Formal Syntax Error detection codes Security","headings3":"Adversary capabilities Goals"},"icry/Key Derivation Function.md":{"basename":"Key Derivation Function","content":"(KDF)\n\n> Deriving fresh session keys from master keys\n\n- Constructed by combining [[Hash Functions]]\n\n![[double-ratchet-kdf.png]]\n","path":"icry/Key Derivation Function.md","mtime":1666090977192,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/HMAC.md":{"basename":"HMAC","content":"> Hashed Message Authentication Code\n\n- Ensures that no one is able to modify the hash\n- Faster than [[Message Authentication Codes#Secure CBC-MAC]]\n\nUses a secret passphrase common to both sides. We then calculate the checksum using:\n\n$$Hash = H(\\text{value to be hashed } || \\text{ secret passphrase})$$\n\n![[hmac.png]]","path":"icry/HMAC.md","mtime":1666093103037,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/Cipher Block Chaining.md":{"basename":"Cipher Block Chaining","content":"Fixes [[Electronic Codebook]] deterministic encryption\n- For [[Block Ciphers]]\n\n- [[Electronic Codebook]] is not [[IND-CPA Security]] secure\n\n- Randomize plaintext blocks with previous block ciphertexts, use a random *initialization vector* ($IV$) for the first block\n- IND-CPA secure if $E$ is a secure block cipher (secure PRP)\n- ##### Q: Can this be parallelized?\n\n![[cipher-block-chaining.png]]\n\n## Output Feedback Mode\n\n(OFB)\n\n> We don't need to encipher the message blocks to encrypt them, we can use block ciphers similarly to stream ciphers\n\n- Encipher IV and feed output back into next block\n\t- ##### Q: Dose $E$ need to be a permutation?\n\n- IND-CPA secure\n- Allows pre-computation\n\n![[output-feedback-mode.png]]\n\n## Cipher Feedback Mode\n\n(CFB)\n\n- Similar to [[Cipher Block Chaining#Output Feedback Mode]] but the ciphertext is fed back\n- IND-CPA secure\n##### Q: does it allow pre-computation\n\n![[cipher-feedback-mode.png]]\n\n## Counter Mode\n\n(CTR)\n\n> Reduce dependency between blocks to enable faster processing\n\n- Encipher a random counter, e.g. IV||0, and increment input in each block\n\n- IND-CPA secure\n- Pre-computation, parallelisation, random-access\n\n![[counter-mode.png]]\n\t","path":"icry/Cipher Block Chaining.md","mtime":1666093199253,"tags":[],"aliases":"","headings1":"","headings2":"Output Feedback Mode Cipher Feedback Mode Counter Mode","headings3":""},"icry/Hash Functions.md":{"basename":"Hash Functions","content":"**Digest** output of the hash function\n\n## Security Requirements\n\n- Fast -- not an expensive computation\n- **One way** / **Preimage resistant** given $H(x)$, hard to find $x$\n- **Second-preimage resistance** hard to find collisions with a *given* input\n\t- First input is given, second image to be compared\n- **Collision-resistance** hard to find two inputs with the same digest\n- **Random Oracle** Produces unpredictable random output\n\t- Hash acts as a random function, for any input it is modelled to produce a truly random output\n\n## Usages\n\n- Passwords -- salted hash \n- Integrity checks / Intrusion detection\n\t- System files are \"fingerprinted\" stored in secure vault for comparison with fresh digests\n\t- Requires second-preimage resistance\n- Hash tables\n\t- Requires collision-resistance\n- [[HMAC]] / [[Message Authentication Codes]]\n- Random number generation\n- Proof of Work\n- Deduplication -- e.g. Dropbox only needs to store files with the same hash once\n- [[Key Derivation Function]]\n\n## Merkle-Damgard Construction\n\n- Hash function need to handle *arbitrary* length inputs\n- Break down this problem: hash functions are made of *compression functions* that can handle a block size and give a shorter output\n\t- If we can do this, we can take inputs of any size\n- Input broken into blocks, padded with 1000...0 concatenated with input length in 64 bits\n- If $h$ is collision resistant, then hash function collision resistant\n\n![[merkle-damgard-hash-construction.png]]\n\n\n## Davies-Meyer Construction\n\nConstruct a compression function from a block cipher\n\n- Message block as cipher key\n- Previously hash block as cipher input\n- Compresses from block cipher key + block length to block cipher block length\n\n> If block cipher is an \"ideal\" block cipher, construction is collision resistant\n\n![[davies-meyer-construction.png|300]]\n\n## Sponge Construction\n\nRecent hash functions, SHA-3 (Keccak) based on this\n\n- Security level determined by capacity $c$ and rate $r$\n- Ouput size flexible\n\n![[hash-sponge-construction.png|300]]\n\n## Security\n\n### Preimage\n\nFor an n bit output, a brute force attack has $2{n}$ inputs\nMaximum preimage security level with d-bit output is d bits\n\n### Collision\n\nFor the i-th input $x_i$, we check if $H(x_{i})$ is the same as *any* of the previous ones\n\nSo i-th step has the success probability $i  / 2{256}$\nOverall probability: \n$$\n\\frac{1+2+\\cdot\\cdot\\cdot+i}{2{256}}\n$$\n$$\n= \\frac{i(i+1)}{2 \\times 2{256}}\n$$\n$$= O(i2)/{2{256}}$$\n\n\n- Maximum collision security level a hash function with d-bit output can provide is d/2 -- a brute force attack upper bound is $2{d/2}$\n- **Birthday bound** Generally, if there are $n$ possibilities, random selection will have 50% chance after $\\sqrt{n}$ tries\n\n## Applications\n\n### Merkle Hash Tree\n\n> Only root hash needs to kept secure to detect changes\n\n![[merkle-hash-tree.png|500]]\n\n### Membership Proof\n\n> Prove rec4 is in tree\n\nGive the record and all the orange values, the adjacent hashes on route to the root hash\n\n![[membership-proof.png|500]]\n\n### [[HMAC]]\n\n","path":"icry/Hash Functions.md","mtime":1666094183804,"tags":[],"aliases":"","headings1":"","headings2":"Security Requirements Usages Merkle-Damgård Construction Davies-Meyer Construction Sponge Construction Security Applications","headings3":"Preimage Collision Merkle Hash Tree Membership Proof [[HMAC]]"},"Hire right.md":{"basename":"Hire right","content":"Cisco merkai -- starting date ending date\nYUSU -- starting date","path":"Hire right.md","mtime":1666094484074,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/Public Key Encryption.md":{"basename":"Public Key Encryption","content":"**Keys can be used both ways!**\n- Public key to secret key → confidentiality\n- Secret key to public key → authenticity\n\t- Only person in the world who can encrypt a message which is decrypted with public key is the person with the secret key\n\t- Only Alice can sign (with secret key) *anyone* can verify (just need K, M, and signature (T))\n\t- We *know* Alice has signed this, so she can't claim that she hasn't (if that makes sense)\n\t\t- In symmetric key encryption to prove that Alice had signed we would need access to the secret key\n- Needs [[Public Key Encryption#Public Key Infrastructure]]\n- Slower than [[Symmetric Encryption]]\n\n![[public-key-crypto.png|300]]\n\n## Key Establishment\n\n> Two parties who do not share a key run this protocol to produce a shared key\n\n(Key Exchange, Key agreement)\n\n- TLS, IKE in IPSec\n\n## Non-Repudiation\n\n> Assurance that the sender is provided with proof of delivery and recipient provided with proof of sender's identity\n\n- Neither can later deny having processed information\n\n## [[Diffie-Hellman Key Exchange]]\n\n## Public Key Infrastructure\n\n(PKI)\n","path":"icry/Public Key Encryption.md","mtime":1666097680604,"tags":[],"aliases":"","headings1":"","headings2":"Key Establishment Non-Repudiation [[Diffie-Hellman Key Exchange]] Public Key Infrastructure","headings3":""},"icry/Cryptography.md":{"basename":"Cryptography","content":"## Definitions\n- **Confidentiality**: The message cannot be read by a non-authorised client\n- **Integrity**: On the route from $B$ to $A$, the message has not been changed\n\t- Hash is calculated and added to the packet\n\t- To make sure no one is able to modify the hash, a [[HMAC]] is used\n- **Authenticity**: Message received by $A$ is actually sent by $B$\n\t- $Authenticity \\implies Integrity$\n\t- E.g. Message may retain its integrity, but it could have been sent by $C$ instead of $B$\n\t- Implemented using [[Public Key Encryption]]\n\t- The difference between authenticity and confidentiality is unclear\n\t\n\n- **Primitive** Type of cryptographic tool used in a specific setting\n\t- e.g. [[Symmetric Encryption]], [[Block Ciphers]]\n- **Scheme** specific primitive\n\t- e.g. AES-CRT, Trivium\n- **Security Game** Procedure specifying the capabilities and goal of adversary\n- **Notion of security** Definition of security for a specific primitive against an adversary with specific capabilities and goals\n\t- e.g. IND-CPA security for symmetric encryption\n\n- **Authentication** Proving who you are without revealing further information\n\n\n## Method Comparison\nFor a group of $n$ people to all communicate with each other privately, how many keys do we require?\n- [[Symmetric Encryption]]: $\\frac{n \\times (n - 1)}{2}$\n- [[Public Key Encryption]]: $2n$\n\n- [[Public Key Encryption]] algorithms are *much slower* than [[Symmetric Encryption]]\n- Possibility of using a hybrid system\n\n---\n- [[Encryption Algorithm Formal Syntax]]\n- [[Crytography Security]]\n- [[Indistinguishability]]","path":"icry/Cryptography.md","mtime":1666095314517,"tags":[],"aliases":"","headings1":"","headings2":"Definitions Method Comparison","headings3":""},"icry/Symmetric Encryption.md":{"basename":"Symmetric Encryption","content":"> AES\n\n- **Single key** -- sharing this may be a challenge\n- **Fast** -- possible to use [[Public Key Encryption]] to share the key, and communicate thereafter using symmetric crypto\n- Could also be used for a single client -- for instance encrypting files on your laptop for use later\n\n![[symmetric-crypto.png | 300]]\n\n","path":"icry/Symmetric Encryption.md","mtime":1666095093006,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""},"icry/Modulo Arithmetic.md":{"basename":"Modulo Arithmetic","content":"##### TODO\n\n**Generator** Element that generates whole group by exponentiation\n- If we raise a generator to a random exponent, we get a random value in the group\n\n## Fermat's Little Theorem\n\n\nif $p$ is prime, $\\forall x \\in \\mathbb{Z}{*}$\n","path":"icry/Modulo Arithmetic.md","mtime":1666096867086,"tags":[],"aliases":"","headings1":"","headings2":"Fermat's Little Theorem","headings3":""},"Diffie-Hellman Key Exchange.md":{"basename":"Diffie-Hellman Key Exchange","content":"## Diffie-Hellman Key Exchange\n\n##### TODO\n\n[[Modulo Arithmetic]]\n\nEstablish a shared key using this protocol\n\n1. Alice picks random $a$ in $\\text{Z}{*}_{p}$, calculates $g{a}\\ mod\\ p$ and send it to Bob\n2. Alice picks random $b$ in $\\text{Z}{*}_{p}$, calculates $g{b}\\ mod\\ p$ and send it to Alice\n3. Now Alice knows $a$, $g{b}$ so she calculates\n\t1. $S = (g{b}){a} = g{ab}\\ mod\\ p$\n\t\n## Security\n\n- $g,p$ are public\n- For a large modulus $p$\n\t- From $g{a}$ is hard to calculate $a$ -- *Discrete Logarithm (DL) Problem\n\t- From $g{a}$ and $g{b}$ it is hard to calculate $g{ab}$ -- *Computational Diffie-Hellman (CDH) Problem*\n\t- From $g{a}$ and $g{b}$ it is hard to distinguish $g{ab}$ from a random value -- *Decision Diffie-Hellman (DDH) Problem*\n- So both the ephemeral secrets $a,b$ and the final shared secret $S$ are hard to calculate for an eavesdropper and $S$ \"looks random\"\n- Diffie-Hellman does not authenticate, so does not protect against [[Public Key Encryption#Man-in-the-Middle against Diffie-Hellman]]\n\n## Key Exchange Security\n\nAn adversary with knowledge of $g{a}$ and $g{b}$ has no knowledge of $g{ab}$ for a sufficiently large prime\n\n![[diffie-hellman-security-game.png|300]]\n\n## Man-in-the-Middle\n\n[[Public Key Encryption#Diffie-Hellman Key Exchange]] is not secure against active attacks\n\n![[diffie-hellman-mitm.png]]\n\n\n","path":"Diffie-Hellman Key Exchange.md","mtime":1666178395458,"tags":[],"aliases":"","headings1":"","headings2":"Diffie-Hellman Key Exchange Security Key Exchange Security Man-in-the-Middle","headings3":""},"sys4/UDP.md":{"basename":"UDP","content":"> User Datagram Protocol\n\n![[udp-structure.png]]\n\n- Simple, Low overhead (small header)\n- Unreliable, connectionless service\n\n## Checksum\n\n- 32bit block broken down into 16bit values and accumulated\n- Any overflows are wrapped and added back\n- IP addresses included, to ensure segment received is for this host\n- Final result *inverted* and stored in UDP header\n\nOn receiving UDP packet, zero checksum (obviously)\n- Accumulate all data together then add with the checksum, if correct it should be all zeros (as inverted)\n\n![[udp-checksum-data.png|300]]\n\n![[udp-checksum-calc.png|400]]\n\n## Advantages\n\n##### TODO\n- Low overhead\n\t- small header (8 bytes)\n\t- No connection establishment\n\t- Application code transfer segment as soon\n\n## Disadvantage\n\n##### TODO\n\n#### Q: What is the biggest possible UDP segment SIZE\n\n![[max-udp-segment.png]]\n\n- Max \"safe\" UDP payload: 508 bytes\n- Max packet \"safe\" size: 576 bytes\n\t- 60 byte IP & 8 bytes UDP header\n- UDP segment $\\leq$ 576, guaranteed to be deliverable, not guaranteed to be delivered\n- UDP segment $\\gt$ 576 are allowed to be dropped by any reason by the routers\n- Max possible UDP payload dependent on lower layers\n\t- UDP packet may be fragmented by lower layers\n- **Maximum Transmission Unit** (MTU) for IP frame is ~1500 bytes\n\n\n\n---\n\n[[Internet Protocol Stack#Transport]]","path":"sys4/UDP.md","mtime":1666268791786,"tags":[],"aliases":"","headings1":"","headings2":"Checksum Advantages Disadvantage","headings3":""},"nets/Security.md":{"basename":"Security","content":"## Definitions\n\n- **Computer Security** Protecting computer systems\n- **Information Security** Places focus on protecting information\n\t- Availability, Integrity\n- **Cybersecurity** All of the above, plus communication systems -- system design\n\n- **Subjects** Entity within a system that performs an action.\n- **Actions** Operation, which results in a change to the system state by altering, creating or removing objects.\n- **Objects** Entity within a system on which and action has an effect\n- **State** Snapshot of all the subjects at a given a point in time\n\t- Contains *all* data present in the system\n\n## CIA Triad\n\n> Also known as AIC\n\n- **Confidentiality** Ensures that objects are only accessible by subjects that have need and access rights\n\t- Not to be confused with **Privacy** Legal requirements to be complied with\n- **Integrity** Objects only altered by subjects who have write permissions\n- **Availability** Access and/or alter objects when they are required to\n\t- Precautions against unpredictable events, e.g. fires\n* **Primary identification** User does not need to make any claim beyond that they are permitted to access the system\n\t* No username required\n\n![[cia-triad.png | 500]]\n\n\n\n## Security Policies\n\n- Consider assets and potential harm, and define security policies that apply to them\n- Goal: Prevent the system from ever moving from a secure state to an insecure state.\n\t- Policies assisting moving back from insecure to secure\n\n\n## Security Goals\n\n[[Cryptography#Definitions]]\n- **Confidentiality**\n- **Authentication**\n- **Non-Repudiation** -- party cannot claim they didn't do it\n- **Non-Mallebility**\n\n- **Anonymity**\n- **Availability**\n\n## Security Protocol\n\n- Communication protocol\n- Security protocol -- ensure communication not abused\n\t- Cryptography\n\t- Protect communicating parties\n\t- Challenge-response protocol\n\t\n\n\n\n- [[Access Control]]\n- [[Security Models]]\n- [[Security Concepts]]\n","path":"nets/Security.md","mtime":1666270320959,"tags":[],"aliases":"","headings1":"","headings2":"Definitions CIA Triad Security Policies Security Goals Security Protocol","headings3":""},"Security Goals.md":{"basename":"Security Goals","content":"","path":"Security Goals.md","mtime":1666270104683,"tags":[],"aliases":"","headings1":"","headings2":"","headings3":""}}